<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SQL 支持 - How Query Engines Work (中文版)</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">译者言</a></li><li class="chapter-item expanded "><a href="../1-acknowledgments/index.html"><strong aria-hidden="true">1.</strong> 致谢</a></li><li class="chapter-item expanded "><a href="../2-introduction/index.html"><strong aria-hidden="true">2.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="../3-what_is_a_query_engine/index.html"><strong aria-hidden="true">3.</strong> 什么是查询引擎</a></li><li class="chapter-item expanded "><a href="../4-apache_arrow/index.html"><strong aria-hidden="true">4.</strong> Apache Arrow</a></li><li class="chapter-item expanded "><a href="../5-type_system/index.html"><strong aria-hidden="true">5.</strong> 类型系统</a></li><li class="chapter-item expanded "><a href="../6-data_sources/index.html"><strong aria-hidden="true">6.</strong> 数据源</a></li><li class="chapter-item expanded "><a href="../7-logical_plans/index.html"><strong aria-hidden="true">7.</strong> 逻辑计划和表达式</a></li><li class="chapter-item expanded "><a href="../8-dataframes/index.html"><strong aria-hidden="true">8.</strong> 数据帧</a></li><li class="chapter-item expanded "><a href="../9-physical_plans/index.html"><strong aria-hidden="true">9.</strong> 物理计划和表达式</a></li><li class="chapter-item expanded "><a href="../10-query_planner/index.html"><strong aria-hidden="true">10.</strong> 查询规划器</a></li><li class="chapter-item expanded "><a href="../11-query_optimizations/index.html"><strong aria-hidden="true">11.</strong> 查询优化</a></li><li class="chapter-item expanded "><a href="../12-query_execution/index.html"><strong aria-hidden="true">12.</strong> 查询执行</a></li><li class="chapter-item expanded "><a href="../13-sql_support/index.html" class="active"><strong aria-hidden="true">13.</strong> SQL 支持</a></li><li class="chapter-item expanded "><a href="../14-parallel_query_execution/index.html"><strong aria-hidden="true">14.</strong> 并行查询执行</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">How Query Engines Work (中文版)</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ArkToria/How_Query_Engines_Work" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/ArkToria/How_Query_Engines_Work/edit/main/docs/13-sql_support/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sql-支持"><a class="header" href="#sql-支持">SQL 支持</a></h1>
<blockquote>
<p>本章讨论的源代码可以在 KQuery 的 <a href="https://github.com/andygrove/how-query-engines-work/tree/main/jvm/examples">examples</a> 模块中找到。</p>
</blockquote>
<p>除了具有手动编码逻辑计划的能力外，在某些情况下，仅编写 SQL 将更加方便。在本章节中，我们将构建一个可以将 SQL 查询转化为逻辑计划的 SQL 解析器和查询规划器。</p>
<h2 id="tokenizer-分词器"><a class="header" href="#tokenizer-分词器">Tokenizer 分词器</a></h2>
<p>第一步是将 SQL 查询字符串转换为表示关键字、文字、标识符和操作符的令牌列表。</p>
<p>下面是所有可能令牌的子集，目前已经够用了。</p>
<pre><code class="language-kotlin">interface Token
data class IdentifierToken(val s: String) : Token
data class LiteralStringToken(val s: String) : Token
data class LiteralLongToken(val s: String) : Token
data class KeywordToken(val s: String) : Token
data class OperatorToken(val s: String) : Token
</code></pre>
<p>然后我们需要一个 tokenizer 类。在这里介绍这一点不是特别有趣，完整的代码可以在配套的 <a href="https://github.com/andygrove/how-query-engines-work/blob/main/jvm/sql/src/main/kotlin/SqlTokenizer.kt">Github 仓库</a>中找到。</p>
<pre><code class="language-kotlin">class Tokenizer {
  fun tokenize(sql: String): List&lt;Token&gt; {
    // see github repo for code
  }
}
</code></pre>
<p>给定输入 <code>SELECT a + b FROM c</code>，我们期望可以得到以下输出：</p>
<pre><code class="language-kotlin">listOf(
  KeywordToken(&quot;SELECT&quot;),
  IdentifierToken(&quot;a&quot;),
  OperatorToken(&quot;+&quot;),
  IdentifierToken(&quot;b&quot;),
  KeywordToken(&quot;FROM&quot;),
  IdentifierToken(&quot;c&quot;)
)
</code></pre>
<h2 id="pratt-parser"><a class="header" href="#pratt-parser">Pratt Parser</a></h2>
<blockquote>
<p>译者注：相关阅读可参考 <a href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html">https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html</a></p>
</blockquote>
<p>我们将根据 Vaughan R. Pratt 在 1973 年发表的<a href="http://tdop.github.io/">自顶向下运算符优先级</a>论文，手动编写一个 SQL 解析器。尽管还有其它方法可以构建 SQL 解析器，比如使用解析器生成器和解析器组合器，但我发现 Pratt 的方法很好，而且生成的代码高效，易于理解和调试。</p>
<p>下面是 Pratt 解析器的基本实现。在我看来，它的美丽在于它的简单。表达式解析是通过一个简单的循环来执行的，该循环解析一个 “prefix 前缀” 表达式，然后是可选的 “infix 中缀” 表达式，并继续执行此操作，直到优先级发生改变，使解析器认识到它已经完成了对表达式的解析。当然 <code>parsePrefix</code> 和 <code>parseInfix</code> 实现可以递归地回到 <code>parse</code> 方法中，这就是它变得非常强大的地方。</p>
<pre><code class="language-kotlin">interface PrattParser {
  /** Parse an expression */
  fun parse(precedence: Int = 0): SqlExpr? {
    var expr = parsePrefix() ?: return null
    while (precedence &lt; nextPrecedence()) {
      expr = parseInfix(expr, nextPrecedence())
    }
    return expr
  }

  /** Get the precedence of the next token */
  fun nextPrecedence(): Int

  /** Parse the next prefix expression */
  fun parsePrefix(): SqlExpr?

  /** Parse the next infix expression */
  fun parseInfix(left: SqlExpr, precedence: Int): SqlExpr
}
</code></pre>
<p>这个接口引用了一个新的 SqlExpr 类，它将作为解析表达式的表示形式，并且在很大程度上将是逻辑计划中定义的表达式的一对一映射。但是对于二元表达式，我们可以使用其中运算符是字符串这种更为通用的结构，而不是为我们将支持的所有不同的二进制表达式创建单独的数据结构。</p>
<p>下面是 SqlExpr 实现的一些示例：</p>
<pre><code class="language-kotlin">/** SQL Expression */
interface SqlExpr

/** Simple SQL identifier such as a table or column name */
data class SqlIdentifier(val id: String) : SqlExpr {
  override fun toString() = id
}

/** Binary expression */
data class SqlBinaryExpr(val l: SqlExpr, val op: String, val r: SqlExpr) : SqlExpr {
  override fun toString(): String = &quot;$l $op $r&quot;
}

/** SQL literal string */
data class SqlString(val value: String) : SqlExpr {
  override fun toString() = &quot;'$value'&quot;
}
</code></pre>
<p>有了这些类，就可以用下面的代码表示表达式 <code>foo = bar</code>。</p>
<pre><code class="language-kotlin">val sqlExpr = SqlBinaryExpr(SqlIdentifier(&quot;foo&quot;), &quot;=&quot;, SqlString(&quot;bar&quot;))
</code></pre>
<h2 id="parsing-sql-expressions-解析-sql-表达式"><a class="header" href="#parsing-sql-expressions-解析-sql-表达式">Parsing SQL Expressions 解析 SQL 表达式</a></h2>
<p>让我们通过这种方式来解析一个简单的数学表达式，例如 <code>1 + 2 * 3</code>。该表达式由以下标记组成。</p>
<pre><code class="language-kotlin">listOf(
  LiteralLongToken(&quot;1&quot;),
  OperatorToken(&quot;+&quot;),
  LiteralLongToken(&quot;2&quot;),
  OperatorToken(&quot;*&quot;),
  LiteralLongToken(&quot;3&quot;)
)
</code></pre>
<p>我们需要创建 <code>PrattParser</code> 的 trait 特性实现，然后将令牌传递给构造函数。令牌封装在 <code>TokenStream</code> 类中，该类提供了一些方便的方法，例如用于消费下一个令牌的 <code>next</code>，以及当我们希望在不消费令牌的情况下查看时的 <code>peek</code>。</p>
<pre><code class="language-kotlin">class SqlParser(val tokens: TokenStream) : PrattParser {
}
</code></pre>
<p>实现 <code>nextPrecedence</code> 方法很简单，因为这里只有少量具任何优先级的令牌，并且我们需要使乘法和除法运算符具有比加减法运算符更高的优先级。注意，这个方法返回的具体数字并不重要，因为它们只是用于比较。在 <a href="https://www.postgresql.org/docs/7.2/sql-precedence.html">PostgreSQL 文档</a> 中可以找到一个很好的运算符优先级参考。</p>
<pre><code class="language-kotlin">override fun nextPrecedence(): Int {
  val token = tokens.peek()
  return when (token) {
    is OperatorToken -&gt; {
      when (token.s) {
        &quot;+&quot;, &quot;-&quot; -&gt; 50
        &quot;*&quot;, &quot;/&quot; -&gt; 60
        else -&gt; 0
      }
    }
    else -&gt; 0
  }
}
</code></pre>
<p>前缀解析器只需要知道如何解析字面数值。</p>
<pre><code class="language-kotlin">override fun parsePrefix(): SqlExpr? {
  val token = tokens.next() ?: return null
  return when (token) {
    is LiteralLongToken -&gt; SqlLong(token.s.toLong())
    else -&gt; throw IllegalStateException(&quot;Unexpected token $token&quot;)
  }
}
</code></pre>
<p>中缀解析器只需要知道如何解析运算符。注意，在解析运算符之后，此方法将递归地回调倒顶层解析方法，以解析运算符后面的表达式（二元表达式的右侧）。</p>
<pre><code class="language-kotlin">override fun parseInfix(left: SqlExpr, precedence: Int): SqlExpr {
  val token = tokens.peek()
  return when (token) {
    is OperatorToken -&gt; {
      tokens.next()
      SqlBinaryExpr(left, token.s, parse(precedence) ?:
                    throw SQLException(&quot;Error parsing infix&quot;))
    }
    else -&gt; throw IllegalStateException(&quot;Unexpected infix token $token&quot;)
  }
}
</code></pre>
<p>优先级逻辑可以通过解析数学表达式 <code>1 + 2 * 3</code> 和 <code>1 * 2 + 3</code>来证明，它们应该分别被解析为 <code>1 + (2 * 3)</code> 和 <code>(1 * 2) + 3</code>。</p>
<p>例如：解析 <code>1 + 2 _ 3 *</code>。</p>
<p>以下是令牌及其优先级值。</p>
<pre><code class="language-kotlin">Tokens:      [1]  [+]  [2]  [*]  [3]
Precedence:  [0] [50]  [0] [60]  [0]
</code></pre>
<p>最终结果将表达式正确地表述为 <code>1 + (2 * 3)</code>。</p>
<pre><code class="language-kotlin">SqlBinaryExpr(
    SqlLong(1),
    &quot;+&quot;,
    SqlBinaryExpr(SqlLong(2), &quot;*&quot;, SqlLong(3))
)
</code></pre>
<p>例如：解析 <code>1 _ 2 + 3*</code>。</p>
<pre><code class="language-kotlin">Tokens:      [1]  [*]  [2]  [+]  [3]
Precedence:  [0] [60]  [0] [50]  [0]
</code></pre>
<p>最终结果将表达式正确地表述为 <code>(1 * 2) + 3</code>。</p>
<pre><code class="language-kotlin">SqlBinaryExpr(
    SqlBinaryExpr(SqlLong(1), &quot;*&quot;, SqlLong(2)),
    &quot;+&quot;,
    SqlLong(3)
)
</code></pre>
<h2 id="parsing-a-select-statement-解析-select-语句"><a class="header" href="#parsing-a-select-statement-解析-select-语句">Parsing a SELECT statement 解析 SELECT 语句</a></h2>
<p>现在我们已经能够解析一些简单地表达式了，下一步是扩展解析器，以支持将 SELECT 语句解析为具体的语法树 (CST)。请注意，对于其它的解析方法，例如使用像 <a href="https://www.antlr.org/">ANTLR</a> 这样的解析生成器，会有一个称为抽象语法树 (AST) 的中间阶段，然后需要将其转换为具体语法树，但是使用 Pratt 解析器方法，我们可以直接从令牌转换为具体语法树。</p>
<p>下面是一个示例 CST，它可以表示带有映射和选择的简易单表查询。将在后面的章节中对齐进行扩展以支持更复杂的查询。</p>
<pre><code class="language-kotlin">data class SqlSelect(
    val projection: List&lt;SqlExpr&gt;,
    val selection: SqlExpr,
    val tableName: String) : SqlRelation
</code></pre>
<h2 id="sql-query-planner-sql-查询规划器"><a class="header" href="#sql-query-planner-sql-查询规划器">SQL Query Planner SQL 查询规划器</a></h2>
<p>SQL 查询规划器将 SQL 查询树转换为逻辑计划。由于 SQL 语言的灵活性，这将比逻辑计划转换为物理计划要困难得多。例如，考虑下面的简单查询：</p>
<pre><code class="language-kotlin">SELECT id, first_name, last_name, salary/12 AS monthly_salary
FROM employee
WHERE state = 'CO' AND monthly_salary &gt; 1000
</code></pre>
<p>虽然这对于阅读的人来说很直观，但是查询的选择部分 (<code>WHERE</code> 子句) 引用了一个表达式 (<code>state</code>)，该表达式不包含在映射的输出中，因此显然需要在映射前应用，当它同时也应用了另一个表达式 (<code>salary/12 AS monthly_salary</code>)，该表达式只有在应用映射后才可用。在使用 <code>GROUP BY</code>、<code>HAVING</code> 和 <code>ORDER BY</code> 子句时，我们也会遇到类似的问题。</p>
<p>这个问题有多种解决方案。一种方案是将此查询转换未以下逻辑计划，将表达式分成两个步骤，一个在映射前，另一个在映射后。但是，这样可行仅仅是因为所选的表达式是一个结合性谓词（只有在所有部分都是正确的情况下，表达式是正确的），而对于更复杂的表达式来说，这种方法可能无法使用。如果该表达式变为 <code>state = 'CO' OR monthly_salary &gt; 1000</code>，那么我们将无法执行此操作。</p>
<pre><code class="language-SQL">Filter: #monthly_salary &gt; 1000
  Projection: #id, #first_name, #last_name, #salary/12 AS monthly_salary
    Filter: #state = 'CO'
      Scan: table=employee
</code></pre>
<p>一种更加简单通用的方法是将所有必须的表达式加到映射中，以便可以在映射后应用选择，然后通过在另一个映射中封装输出来移除所有多余的列。</p>
<pre><code class="language-kotlin">Projection: #id, #first_name, #last_name, #monthly_salary
  Filter: #state = 'CO' AND #monthly_salary &gt; 1000
    Projection: #id, #first_name, #last_name, #salary/12 AS monthly_salary, #state
      Scan: table=employee
</code></pre>
<p>值得注意的是，我们将在后面的章节中构建一个 &quot;Predicate Push Down&quot; 查询优化器规则，它能够优化该计划，并将谓词的 <code>state = 'CO'</code> 部分推到计划的更下方，使其位于映射之前。</p>
<h2 id="translating-sql-expressions-转换-sql-表达式"><a class="header" href="#translating-sql-expressions-转换-sql-表达式">Translating SQL Expressions 转换 SQL 表达式</a></h2>
<p>将 SQL 表达式转换未逻辑表达式相当简单，如本示例代码所示：</p>
<pre><code class="language-kotlin">private fun createLogicalExpr(expr: SqlExpr, input: DataFrame) : LogicalExpr {
  return when (expr) {
    is SqlIdentifier -&gt; Column(expr.id)
    is SqlAlias -&gt; Alias(createLogicalExpr(expr.expr, input), expr.alias.id)
    is SqlString -&gt; LiteralString(expr.value)
    is SqlLong -&gt; LiteralLong(expr.value)
    is SqlDouble -&gt; LiteralDouble(expr.value)
    is SqlBinaryExpr -&gt; {
      val l = createLogicalExpr(expr.l, input)
      val r = createLogicalExpr(expr.r, input)
      when(expr.op) {
        // comparison operators
        &quot;=&quot; -&gt; Eq(l, r)
        &quot;!=&quot; -&gt; Neq(l, r)
        &quot;&gt;&quot; -&gt; Gt(l, r)
        &quot;&gt;=&quot; -&gt; GtEq(l, r)
        &quot;&lt;&quot; -&gt; Lt(l, r)
        &quot;&lt;=&quot; -&gt; LtEq(l, r)
        // boolean operators
        &quot;AND&quot; -&gt; And(l, r)
        &quot;OR&quot; -&gt; Or(l, r)
        // math operators
        &quot;+&quot; -&gt; Add(l, r)
        &quot;-&quot; -&gt; Subtract(l, r)
        &quot;*&quot; -&gt; Multiply(l, r)
        &quot;/&quot; -&gt; Divide(l, r)
        &quot;%&quot; -&gt; Modulus(l, r)
        else -&gt; throw SQLException(&quot;Invalid operator ${expr.op}&quot;)
      }
    }

    else -&gt; throw new UnsupportedOperationException()
  }
}
</code></pre>
<h2 id="planning-select-规划-select"><a class="header" href="#planning-select-规划-select">Planning SELECT 规划 SELECT</a></h2>
<p>如果我们只想支持所选列引用也全都存在于映射中，我们也可以使用一些非常简单的逻辑来构建查询计划。</p>
<pre><code class="language-kotlin">fun createDataFrame(select: SqlSelect, tables: Map&lt;String, DataFrame&gt;) : DataFrame {

  // get a reference to the data source
  var df = tables[select.tableName] ?:
      throw SQLException(&quot;No table named '${select.tableName}'&quot;)

  val projectionExpr = select.projection.map { createLogicalExpr(it, df) }

  if (select.selection == null) {
    // apply projection
    return df.select(projectionExpr)
  }

  // apply projection then wrap in a selection (filter)
  return df.select(projectionExpr)
           .filter(createLogicalExpr(select.selection, df))
}
</code></pre>
<p>然而，由于选择可以映射的输入和输出，因此我们需要创建一个带有中间映射的更复杂的计划。第一步是通过选择过滤器表达式以确定哪些列是被引用到的。为此，我们将使用访问者模式遍历表达式树，并构建一个可变的列名称集合。</p>
<p>下面是我们将用于遍历表达式树的方法：</p>
<pre><code class="language-kotlin">private fun visit(expr: LogicalExpr, accumulator: MutableSet&lt;String&gt;) {
  when (expr) {
    is Column -&gt; accumulator.add(expr.name)
    is Alias -&gt; visit(expr.expr, accumulator)
    is BinaryExpr -&gt; {
      visit(expr.l, accumulator)
      visit(expr.r, accumulator)
     }
  }
}
</code></pre>
<p>至此，我们现在可以编写以下代码，将 SELECT 语句转换为有效的逻辑计划。下面的示例代码并不完美，并且在特殊情况下下可能包含一些错误，例如数据源中的列和别名表达式之间存在名称冲突，但是为了保持代码简洁，我们将暂时忽略这一点。</p>
<pre><code class="language-kotlin">fun createDataFrame(select: SqlSelect, tables: Map&lt;String, DataFrame&gt;) : DataFrame {

  // get a reference to the data source
  var df = tables[select.tableName] ?:
    throw SQLException(&quot;No table named '${select.tableName}'&quot;)

  // create the logical expressions for the projection
  val projectionExpr = select.projection.map { createLogicalExpr(it, df) }

  if (select.selection == null) {
    // if there is no selection then we can just return the projection
    return df.select(projectionExpr)
  }

  // create the logical expression to represent the selection
  val filterExpr = createLogicalExpr(select.selection, df)

  // get a list of columns references in the projection expression
  val columnsInProjection = projectionExpr
    .map { it.toField(df.logicalPlan()).name}
    .toSet()

  // get a list of columns referenced in the selection expression
  val columnNames = mutableSetOf&lt;String&gt;()
  visit(filterExpr, columnNames)

  // determine if the selection references any columns not in the projection
  val missing = columnNames - columnsInProjection

  // if the selection only references outputs from the projection we can
  // simply apply the filter expression to the DataFrame representing
  // the projection
  if (missing.size == 0) {
    return df.select(projectionExpr)
             .filter(filterExpr)
  }

  // because the selection references some columns that are not in the
  // projection output we need to create an interim projection that has
  // the additional columns and then we need to remove them after the
  // selection has been applied
  return df.select(projectionExpr + missing.map { Column(it) })
           .filter(filterExpr)
           .select(projectionExpr.map {
              Column(it.toField(df.logicalPlan()).name)
            })
}
</code></pre>
<h2 id="planning-for-aggregate-queries-规划聚合查询"><a class="header" href="#planning-for-aggregate-queries-规划聚合查询">Planning for Aggregate Queries 规划聚合查询</a></h2>
<p>如你所见，SQL 查询规划器相对复杂，解析聚合查询的代码则更有甚之。如果你对此有兴趣了解更多，请参阅源代码。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../12-query_execution/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../14-parallel_query_execution/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../12-query_execution/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../14-parallel_query_execution/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
