<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>How Query Engines Work (中文版)</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">译者言</a></li><li class="chapter-item expanded "><a href="1-acknowledgments/index.html"><strong aria-hidden="true">1.</strong> 致谢</a></li><li class="chapter-item expanded "><a href="2-introduction/index.html"><strong aria-hidden="true">2.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="3-what_is_a_query_engine/index.html"><strong aria-hidden="true">3.</strong> 什么是查询引擎</a></li><li class="chapter-item expanded "><a href="4-apache_arrow/index.html"><strong aria-hidden="true">4.</strong> Apache Arrow</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">How Query Engines Work (中文版)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="how-query-engines-work-中文版"><a class="header" href="#how-query-engines-work-中文版">How Query Engines Work 中文版</a></h1>
<p>阅读地址: <a href="https://query.arktoria.org">https://query.arktoria.org</a></p>
<p>英文原版: <a href="https://howqueryengineswork.com/">https://howqueryengineswork.com/</a></p>
<p>原文许可：Copyright © 2020-2023 Andy Grove. All rights reserved</p>
<p>译文许可：Creative Commons Attribution-ShareAlike 4.0 International License</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="致谢"><a class="header" href="#致谢">致谢</a></h1>
<p>如果没有我家人的支持，这本书也不可能完成，但我沉浸在这个附属项目中的时候，他们给予了我极大的耐心。</p>
<p>特别感谢 Matthew Powers，又名 Mr.Powers，他在一开始就激发了我写这本书的灵感。Matthew 是 《Writing Beautiful Apache Spark Code》的作者，这本书也可以在 <a href="https://leanpub.com/beautiful-spark">Leanpub</a> 上找到。</p>
<p>同样也得感谢在过去几年从事 <a href="https://github.com/apache/arrow-datafusion">DataFusion</a> 项目期间与我有过互动的无数人，特别是 Apache Arrow PMC、以及其他的提交者和贡献者。</p>
<p>最后，我要感谢在 RMS 工作期间 Chris George 和 Joe Buszkiewic 对我的支持和鼓励，在那里我进一步加深了对查询引擎的理解。</p>
<p>这本书也可以在 <a href="https://leanpub.com/how-query-engines-work">https://leanpub.com/how-query-engines-work</a> 以 ePub、MOBI 和 PDF 格式购买。</p>
<p><strong>Copyright © 2020-2023 Andy Grove. All rights reserved.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>我自从开始第一份软件工程师的工作以来，一直痴迷于数据库和查询语言。向计算机提问并且高效地获取有用的数据是一件非常神奇的事情。在做了多年的常规软件开发人员和数据技术的终端用户后，我开始为一家初创公司工作，这让我深入了解分布式数据开发。这是一本我开始这段旅程之前就已经存在的书。尽管它只是一本入门级的书，当我希望能够揭开查询引擎工作原理的神秘面纱。</p>
<p>我对于查询引擎的性质最终致使我参与了 Apache Arrow 项目，在该项目中，我在 2018 年贡献了最初的 Rust 实现，然后再 2019 年贡献了 DataFusion 内存式查询引擎，最终在 2021 年贡献了 Ballista 分布式计算项目。</p>
<p>在 Rust 实现方面，Arrow 项目现在有着许多活跃的提交者和贡献者，并且与我最初贡献的版本相比，它有了显著的改进。</p>
<p>尽管对于高性能查询引擎而言，Rust 语言是一个不错的选择，但它并不适合教授关于查询引擎的概念，因此我最近在写这本书的适合用 Kotlin 实现了一个新的查询引擎。Kotlin 是一门非常简洁易读的语言，因此可以子啊本书中包含源代码示例。我将鼓励您在阅读本书的过程中熟悉源代码，并考虑做出一些贡献。没有什么是比实践更好的学习方法了。</p>
<p>本书中涉及的查询引擎最初是打算作为 Ballista 项目的一部分（并且持续了一段时间），但随着项目的发展，很明显，通过 UDF(用户定义函数) 机制将查询引擎保留在 Rust 中并支持 Java 和其它语言将更有意义，而不是在多种语言中重复大量的查询执行逻辑。</p>
<p>现在 Ballista 项目已经贡献给了 Apache Arrow，我已经将这本书中配套代码库中的查询引擎简单地称为 &quot;KQuery&quot;，是 Kotlin Query Engine 的简称，但如果有人有更好的名称建议，请告诉我。</p>
<p>这本书的后续篇章将可用版本更新时免费提供，因此请偶尔查看本书地址或者在 Twitter 上关注我 (@andygrove_io) 以便接收新内容可用通知。</p>
<h2 id="反馈"><a class="header" href="#反馈">反馈</a></h2>
<p>如果您对本书有任何反馈，可以给我的 Twitter 账户 @andygrove_io 发送站内信或者向 agrove@apache.org 发送邮件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是查询引擎"><a class="header" href="#什么是查询引擎">什么是查询引擎</a></h1>
<p>查询引擎是一种软件，它可以对数据进行查询，以产生问题的答案，例如：</p>
<ul>
<li>今年到目前为止，我每月的平均销售额是多少？</li>
<li>在过去的一天里，我的网站上最受欢迎的五个网页是什么？</li>
<li>与一年前相比，网络流量的月度情况如何？</li>
</ul>
<p>最广泛使用的查询语言是结构化查询语言 (简称 SQL)。许多开发人员在他们的职业生涯中都会遇到关系型数据库，如 MySQL、Postgres、Oracle 或 SQL Server。所有这些数据库都包含支持 SQL 的查询引擎。</p>
<p>这里有一些 SQL 请求示例：</p>
<blockquote>
<p>SQL 示例：月平均销售额</p>
</blockquote>
<pre><code class="language-sql">SELECT month, AVG(sales)
FROM product_sales
WHERE year = 2020
GROUP BY month;
</code></pre>
<blockquote>
<p>SQL 示例：昨天最热门的五个网页</p>
</blockquote>
<pre><code class="language-sql">SELECT page_url, COUNT(*) AS num_visits
FROM apache_log
WHERE event_date = yesterday()
GROUP BY page_url
ORDER BY num_visits DESC
LIMIT 5;
</code></pre>
<p>SQL 功能强大且广为人知，但在所谓的 “大数据” 世界中存在局限性，数据科学家通常需要将自定义代码和查询混合在一起。Apache Hadoop、Apache Hive 和 Apache Spark 等平台和工具现在被广泛用于查询和操作大量数据。</p>
<blockquote>
<p>Apache Spark 使用 DataFrame 查询示例：</p>
</blockquote>
<pre><code class="language-kotlin">val spark: SparkSession = SparkSession.builder
  .appName(&quot;Example&quot;)
  .master(&quot;local[*]&quot;)
  .getOrCreate()

val df = spark.read.parquet(&quot;/mnt/nyctaxi/parquet&quot;)
  .groupBy(&quot;passenger_count&quot;)
  .sum(&quot;fare_amount&quot;)
  .orderBy(&quot;passenger_count&quot;)

df.show()
</code></pre>
<h2 id="为什么查询引擎广受欢迎"><a class="header" href="#为什么查询引擎广受欢迎">为什么查询引擎广受欢迎</a></h2>
<p>数据增长的加速度越来越大，通常无法在一台计算机上容纳。需要专业的工程师来编写分布式代码以查询数据，并且每次需要从数据中获取新答案时都编写自定义代码是不切实际的。查询引擎提供了一组标准操作和转换方式，因此终端用户可以通过以不同方式将简单的查询语言或应用程序编程接口 (API) 进行组合和转换，并进行调优以获得良好的性能。</p>
<h2 id="本书涵盖了什么内容"><a class="header" href="#本书涵盖了什么内容">本书涵盖了什么内容</a></h2>
<p>本书概述了构建通用查询引擎所涉及的每个步骤。本书中讨论的查询引擎是专门为本书开发的一个简单的查询疫情，其代码是在编写本书内容的同时开发的，以确保我在面临涉及决策时可以编写有关的主题内容。</p>
<h2 id="源代码"><a class="header" href="#源代码">源代码</a></h2>
<p>本书所讨论的完整的查询引擎代码在 Github 仓库：</p>
<blockquote>
<p>https://github.com/andygrove/how-query-engines-work</p>
</blockquote>
<p>有关使用 Gradle 构建项目的最新说明请参阅项目中的 README 文档。</p>
<h2 id="为什么使用-kotlin"><a class="header" href="#为什么使用-kotlin">为什么使用 Kotlin?</a></h2>
<p>本书的重点是查询引擎设计，这通常是编程语言不可或缺的。我在本书中之所以选择 Kotlin，是因为它简洁易懂。并且它也与 Java 100% 兼容，这意味着您可以从 Java 或者其它基于 Java 的语言 (比如 Scala) 调用 Kotlin 代码。</p>
<p>尽管如此，Apache Arrow 项目中的 DataFusion 查询引擎也主要是基于本书中的设计。对 Rust 比 JVM 更感兴趣的读者可以参考 DataFusion 源代码和本书。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-arrow"><a class="header" href="#apache-arrow">Apache Arrow</a></h1>
<p>Apache Arrow 最开始是作为列式数据的内存规范，并以 Java 和 C++ 进行实现。这种内存格式对于支持 SIMD (单指令，多数据) 的 CPU 和 GPU 等现代硬件的矢量化处理是非常有效率的的。</p>
<p>采用标准化的数据内存格式有以下几个好处：</p>
<ul>
<li>
<p>如 Python 或 Java 等高级语言可以通过传递数据指针来调用 Rust 或 C++ 等低级语言来完成计算密集型任务，而不是以另一种格式复制数据，这样造成的开销会非常大。</p>
</li>
<li>
<p>由于内存格式也是网络传输格式 (尽管数据也能被压缩)，数据可以在进程之间有效的地传输，而不需要太多的序列化开销。</p>
</li>
<li>
<p>它应该能让数据科学和数据分析领域的各种开源和商业项目之间构建连接器、驱动程序和集成变得更加容易，并允许开发人员使用他们偏好的语言来利用这些平台。</p>
</li>
</ul>
<p>Apache Arrow 现在在许多编程语言中都有实现，包括 C、C++、C#、Go、Java、JavaScript、Julia、MATLAB、Python、R、Ruby 和 Rust。</p>
<h2 id="arrow-内存模型"><a class="header" href="#arrow-内存模型">Arrow 内存模型</a></h2>
<p>在 <a href="https://arrow.apache.org/docs/format/Columnar.html">Arrow</a> 的网站上详细描述了这一内存模型，但实际上每一个列都是由单个向量表示，其中包含原始数据，以及表示空值的独立向量和可变宽度类型的原始数据偏移量。</p>
<h2 id="inter-process-communication-ipc-程间通讯"><a class="header" href="#inter-process-communication-ipc-程间通讯">Inter-Process Communication (IPC) 程间通讯</a></h2>
<p>正如之前所提，可以通过指针在进程和进程之间传递数据。然而，接收进程需要知道如何解析这些数据，因此交换元数据 (如 schema 结构信息) 定义了 IPC 的数据格式。Arrow 使用 Google Flatbuffers 进行元数据格式定义。</p>
<h2 id="compute-kernels-计算内核"><a class="header" href="#compute-kernels-计算内核">Compute Kernels 计算内核</a></h2>
<p>Apache Arrow 的范围已经扩展到提供计算库来评估数据表达式。Java、C++、C、Python、Ruby、Go、Rust 和 JavaScript 实现等都包含了用于在 Arrow 内存块上执行计算的计算库。</p>
<p>由于这本书主要涉及 Java 实现，值得指出的是，Dremio 最近贡献了 Gandiva 项目，这是一个 Java 库，可以将表达式编译为 LLVM，并支持 SIMD。JVM 开发者可以将操作委托给 Gandava 库，并从中获得纯 Java 实现中难以企及的性能提升 。</p>
<h2 id="arrow-flight-protocol"><a class="header" href="#arrow-flight-protocol">Arrow Flight Protocol</a></h2>
<p>最近，Arrow 已经定义了一个名为 <a href="https://arrow.apache.org/docs/format/Flight.html">Flight</a> 的协议，以便在网络上高效地传输 Arrow 数据。Flight 基于 <a href="https://grpc.io/">gRPC</a> 和 <a href="https://protobuf.dev/">Google Protocol Buffers</a>.</p>
<p>Flight 协议由以下方法定义了一个 FlightService:</p>
<blockquote>
<p>译者建议：在阅读下文之前先对 Google Protobuf 和 gRPC 中的 Service、Client Side 接口和 Stream 有所了解。</p>
<p><a href="https://grpc.io/docs/what-is-grpc/introduction/">what is grpc</a></p>
</blockquote>
<h3 id="handshake"><a class="header" href="#handshake">Handshake</a></h3>
<p>客户端与服务端之间的握手。根据服务器的不同，可能需要握手来决定用于未来操作的 Token。根据验证机制，请求和响应应都是允许多次往返的数据流 (gRPC Stream)。</p>
<h3 id="lightflights"><a class="header" href="#lightflights">LightFlights</a></h3>
<p>获取给定特定条件下的可用流列表。大多数 Flight 服务都会公开一个或多个流。这个 API 允许列出可用的流。用户也可以提供一套标准，用于限制通过该接口列出的流的子集。每个 Flight 服务都允许自己定义如何使用标准。</p>
<h3 id="getflightinfo"><a class="header" href="#getflightinfo">GetFlightInfo</a></h3>
<p>对于给定的 FilgthDescriptor，获取有关 Flight 可以如何被消费的信息。如果接口的使用者已经可以识别要消费的特定 Flight，那这将会是一个非常有用的接口。该接口还允许消费者通过指定的描述符生成 Flight 流。例如：一个 Flight 描述符可能包含待执行的 SQL 语句或<a href="https://docs.python.org/3/library/pickle.html">序列化的 Python 操作</a>。在这些情况下，之前在 ListFilghts 可用流列表中未提供的流，反而在特定的 Flight 服务定义期间是可用的。</p>
<h3 id="getschema"><a class="header" href="#getschema">GetSchema</a></h3>
<p>对于给定的 FlightDescriptor，获取 Schema.fbs::Schema 中描述的 Schema。该接口被用于当消费者需要 Flight 流的 Schema 时。与 GetFlightInfo 类似，该接口可以生成一个之前在 ListFlights 可用列表中未列出的新的 Flight。</p>
<h3 id="doget"><a class="header" href="#doget">DoGet</a></h3>
<p>检索与引用 ticket 相关的特定描述符所关联的单个流。Flight 可以由一个或多个数据流组成，其中每个数据流都可以使用单独的 opaque ticket 不透明凭证进行检索，Flight 服务使用该 ticket 管理数据流的集合。</p>
<h3 id="doput"><a class="header" href="#doput">DoPut</a></h3>
<p>将流推送到与特定 Flight 流相关的 Flight 服务。这允许 Flight 服务的客户端上传数据流。根据特定的 Flight 服务，可以允许客户端消费者上传每个描述符的单个流，也可以上传数量不限的流。后者，服务可能会实现一个 &quot;seal&quot; 动作，一旦所有的流被上传，这个动作就可以应用到一个描述符上。</p>
<h3 id="doexchange"><a class="header" href="#doexchange">DoExchange</a></h3>
<p>为指定描述符打开双向数据通道。这允许客户端在单个逻辑流中发送和接收任意 Arrow 数据和特定应用程序的元数据。与 DoGet/DoPut 不同的是，这样操作更适合将计算（而非存储）转移到 Flight 服务的客户端。</p>
<h3 id="doaction"><a class="header" href="#doaction">DoAction</a></h3>
<p>除了可能提供的 ListFlights、GetFlightInfo、DoGet 和 DoPut 操作外，Flight 服务还可以支持任意数量的简单操作。DoAction 允许 Flight 客户端对 Flight 服务执行特定事件。一个事件包括 opaque request 匿名请求和响应对象，这些对象与所执行的事件类型有关。</p>
<h3 id="listactions"><a class="header" href="#listactions">ListActions</a></h3>
<p>Flight 服务会暴露出所有可用的事件类型及其说明。这可以让不同的 Flight 消费者了解到 Flight 服务所提供的功能。</p>
<h2 id="arrow-flight-sql"><a class="header" href="#arrow-flight-sql">Arrow Flight SQL</a></h2>
<p>有人提议为 Arrow Flight 添加 SQL 功能。在撰写本报告时 (2021 年 1 月)，有一份 C++ 实现的 PR，跟踪 Issue 是 <a href="https://github.com/apache/arrow/pull/12616">ARROW-14698</a>。</p>
<h2 id="查询引擎"><a class="header" href="#查询引擎">查询引擎</a></h2>
<h3 id="datafusion"><a class="header" href="#datafusion">DataFusion</a></h3>
<p>Arrow 的 Rust 实现包含一个名为 DataFusion 的内存查询引擎，该引擎于 2019 年贡献给该项目。该项目正在迅速成熟，并获得了越来越多的关注。例如，InfluxData 正在利用 DataFusion 构建<a href="https://www.influxdata.com/glossary/apache-datafusion/">下一代 InfluxDB 内核</a>。</p>
<h3 id="ballista"><a class="header" href="#ballista">Ballista</a></h3>
<p>Ballista 是一个主要由 Rust 实现、Apache Arrow 支持的的分布式计算平台。它的架构允许其它编程语言 (如 Python、C++ 和 Java) 作为一等公民获得支持，而无需考虑序列化开销。</p>
<p>Ballista 的技术基础如下：</p>
<ul>
<li>Apache Arrow 用于内存模型和类型系统</li>
<li>Apache Arrow Flight 协议，用于在进程间高效传输数据</li>
<li>Apache Arrow Flight SQL 协议，用于商业智能工具和 JDBC 驱动程序连接 Ballista 集群</li>
<li>Google Protocol Buffers，用于序列化查询计划、</li>
<li>Docker 用于打包执行器和用户自定义代码</li>
<li>Kubernetes 用于部署和管理执行器所在的 docker 容器</li>
</ul>
<p>Ballista 于 2021 年贡献给 Arrow 项目，目前还不能用于生产，不过它能够以良好的性能运行主流 TPC-H 基准中的许多查询案例。</p>
<h3 id="c-query-engine"><a class="header" href="#c-query-engine">C++ Query Engine</a></h3>
<p>新增的 C++ 版本查询引擎正在实现中，当下的重点是实现高效计算和数据集 API。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
